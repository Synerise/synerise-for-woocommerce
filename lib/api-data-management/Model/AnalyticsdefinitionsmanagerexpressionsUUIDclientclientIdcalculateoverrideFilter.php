<?php
/**
 * AnalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilter
 *
 * PHP version 5
 *
 * @category Class
 * @package  Synerise\DataManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Data Management
 *
 * Welcome to Synerise API Reference! We hope that you'll enjoy your stay here.  If you need help with our services, feel free to contact us at  [support@synerise.com](mailto:support@synerise.com).  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * OpenAPI spec version: Jul 4, 2022 12:12:40 PM
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Synerise\DataManagement\Model;

use \ArrayAccess;
use \Synerise\DataManagement\ObjectSerializer;

/**
 * AnalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilter Class Doc Comment
 *
 * @category Class
 * @description Client filter. This allows you to limit the calculation to customers who match certain criteria.
 * @package  Synerise\DataManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AnalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilter implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'analyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverride_filter';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'matching' => 'bool',
'expressions' => '\Synerise\DataManagement\Model\OneOfanalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilterExpressionsItems[]',
'expression' => 'OneOfanalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilterExpression'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'matching' => null,
'expressions' => null,
'expression' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'matching' => 'matching',
'expressions' => 'expressions',
'expression' => 'expression'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'matching' => 'setMatching',
'expressions' => 'setExpressions',
'expression' => 'setExpression'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'matching' => 'getMatching',
'expressions' => 'getExpressions',
'expression' => 'getExpression'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['matching'] = isset($data['matching']) ? $data['matching'] : null;
        $this->container['expressions'] = isset($data['expressions']) ? $data['expressions'] : null;
        $this->container['expression'] = isset($data['expression']) ? $data['expression'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets matching
     *
     * @return bool
     */
    public function getMatching()
    {
        return $this->container['matching'];
    }

    /**
     * Sets matching
     *
     * @param bool $matching When `true`, the results include only data that matched the condition. When `false`, the results include only data that did not match the condition.
     *
     * @return $this
     */
    public function setMatching($matching)
    {
        $this->container['matching'] = $matching;

        return $this;
    }

    /**
     * Gets expressions
     *
     * @return \Synerise\DataManagement\Model\OneOfanalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilterExpressionsItems[]
     */
    public function getExpressions()
    {
        return $this->container['expressions'];
    }

    /**
     * Sets expressions
     *
     * @param \Synerise\DataManagement\Model\OneOfanalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilterExpressionsItems[] $expressions Client filter details. The expressions are applied according to their position in the array. The logical operator must be placed between expressions.  An empty array equals to no filters applied.
     *
     * @return $this
     */
    public function setExpressions($expressions)
    {
        $this->container['expressions'] = $expressions;

        return $this;
    }

    /**
     * Gets expression
     *
     * @return OneOfanalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilterExpression
     */
    public function getExpression()
    {
        return $this->container['expression'];
    }

    /**
     * Sets expression
     *
     * @param OneOfanalyticsdefinitionsmanagerexpressionsUUIDclientclientIdcalculateoverrideFilterExpression $expression **IMPORTANT!** It is currently recommended to omit this object in POST and PUT queries. <details><summary>Click here to learn more</summary> This is a structure intended for use in the future. Sending this object is currently optional - it is generated automatically from the contents of the \"expressions\" array. Sending this object and omitting the \"expressions\" array results in an empty filter. Filters defined in this object are overridden by the ones defined in the `expressions` array.  This can be a single condition or a series of nested conditions built using the \"Function\" type. A function is an AND/OR condition and can include other functions, allowing you to build a complex logic.</details>
     *
     * @return $this
     */
    public function setExpression($expression)
    {
        $this->container['expression'] = $expression;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}

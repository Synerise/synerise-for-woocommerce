<?php
/**
 * EventsApi
 * PHP version 5
 *
 * @category Class
 * @package  Synerise\DataManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Data Management
 *
 * Welcome to Synerise API Reference! We hope that you'll enjoy your stay here.  If you need help with our services, feel free to contact us at  [support@synerise.com](mailto:support@synerise.com).  # Authentication  <!-- ReDoc-Inject: <security-definitions> -->
 *
 * OpenAPI spec version: Jul 4, 2022 12:12:40 PM
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Synerise\DataManagement\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Synerise\DataManagement\ApiException;
use Synerise\DataManagement\Configuration;
use Synerise\DataManagement\HeaderSelector;
use Synerise\DataManagement\ObjectSerializer;

/**
 * EventsApi Class Doc Comment
 *
 * @category Class
 * @package  Synerise\DataManagement
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class EventsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation applicationStarted
     *
     * Application started
     *
     * @param  \Synerise\DataManagement\Model\EventsApplicationstartedBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function applicationStarted($body, $api_version)
    {
        $this->applicationStartedWithHttpInfo($body, $api_version);
    }

    /**
     * Operation applicationStartedWithHttpInfo
     *
     * Application started
     *
     * @param  \Synerise\DataManagement\Model\EventsApplicationstartedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function applicationStartedWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->applicationStartedRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation applicationStartedAsync
     *
     * Application started
     *
     * @param  \Synerise\DataManagement\Model\EventsApplicationstartedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applicationStartedAsync($body, $api_version)
    {
        return $this->applicationStartedAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation applicationStartedAsyncWithHttpInfo
     *
     * Application started
     *
     * @param  \Synerise\DataManagement\Model\EventsApplicationstartedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function applicationStartedAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->applicationStartedRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'applicationStarted'
     *
     * @param  \Synerise\DataManagement\Model\EventsApplicationstartedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function applicationStartedRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling applicationStarted'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling applicationStarted'
            );
        }

        $resourcePath = '/events/application-started';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation batchAddOrUpdateTransactions
     *
     * Batch add or update transactions
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody[] $body An array of transactions to post or update (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function batchAddOrUpdateTransactions($body, $api_version)
    {
        $this->batchAddOrUpdateTransactionsWithHttpInfo($body, $api_version);
    }

    /**
     * Operation batchAddOrUpdateTransactionsWithHttpInfo
     *
     * Batch add or update transactions
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody[] $body An array of transactions to post or update (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchAddOrUpdateTransactionsWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->batchAddOrUpdateTransactionsRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation batchAddOrUpdateTransactionsAsync
     *
     * Batch add or update transactions
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody[] $body An array of transactions to post or update (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchAddOrUpdateTransactionsAsync($body, $api_version)
    {
        return $this->batchAddOrUpdateTransactionsAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchAddOrUpdateTransactionsAsyncWithHttpInfo
     *
     * Batch add or update transactions
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody[] $body An array of transactions to post or update (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchAddOrUpdateTransactionsAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->batchAddOrUpdateTransactionsRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchAddOrUpdateTransactions'
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody[] $body An array of transactions to post or update (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function batchAddOrUpdateTransactionsRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling batchAddOrUpdateTransactions'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling batchAddOrUpdateTransactions'
            );
        }

        $resourcePath = '/transactions/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation batchSendEvents
     *
     * Batch send events
     *
     * @param  null[] $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function batchSendEvents($body, $api_version)
    {
        $this->batchSendEventsWithHttpInfo($body, $api_version);
    }

    /**
     * Operation batchSendEventsWithHttpInfo
     *
     * Batch send events
     *
     * @param  null[] $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function batchSendEventsWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->batchSendEventsRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation batchSendEventsAsync
     *
     * Batch send events
     *
     * @param  null[] $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchSendEventsAsync($body, $api_version)
    {
        return $this->batchSendEventsAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation batchSendEventsAsyncWithHttpInfo
     *
     * Batch send events
     *
     * @param  null[] $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchSendEventsAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->batchSendEventsRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'batchSendEvents'
     *
     * @param  null[] $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function batchSendEventsRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling batchSendEvents'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling batchSendEvents'
            );
        }

        $resourcePath = '/events/batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientAddedProductToCart
     *
     * Client added product to cart
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtocartBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientAddedProductToCart($body, $api_version)
    {
        $this->clientAddedProductToCartWithHttpInfo($body, $api_version);
    }

    /**
     * Operation clientAddedProductToCartWithHttpInfo
     *
     * Client added product to cart
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtocartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAddedProductToCartWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientAddedProductToCartRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAddedProductToCartAsync
     *
     * Client added product to cart
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtocartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddedProductToCartAsync($body, $api_version)
    {
        return $this->clientAddedProductToCartAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAddedProductToCartAsyncWithHttpInfo
     *
     * Client added product to cart
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtocartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddedProductToCartAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientAddedProductToCartRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAddedProductToCart'
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtocartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAddedProductToCartRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clientAddedProductToCart'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientAddedProductToCart'
            );
        }

        $resourcePath = '/events/added-to-cart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientAddedProductToFavorites
     *
     * Client added product to favorites
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtofavoritesBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientAddedProductToFavorites($body, $api_version)
    {
        $this->clientAddedProductToFavoritesWithHttpInfo($body, $api_version);
    }

    /**
     * Operation clientAddedProductToFavoritesWithHttpInfo
     *
     * Client added product to favorites
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtofavoritesBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAddedProductToFavoritesWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientAddedProductToFavoritesRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAddedProductToFavoritesAsync
     *
     * Client added product to favorites
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtofavoritesBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddedProductToFavoritesAsync($body, $api_version)
    {
        return $this->clientAddedProductToFavoritesAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAddedProductToFavoritesAsyncWithHttpInfo
     *
     * Client added product to favorites
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtofavoritesBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAddedProductToFavoritesAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientAddedProductToFavoritesRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAddedProductToFavorites'
     *
     * @param  \Synerise\DataManagement\Model\EventsAddedtofavoritesBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAddedProductToFavoritesRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clientAddedProductToFavorites'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientAddedProductToFavorites'
            );
        }

        $resourcePath = '/events/added-to-favorites';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientAppearedInLocation
     *
     * Client appeared in location
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAppearedinlocationBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientAppearedInLocation($api_version, $body = null)
    {
        $this->clientAppearedInLocationWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientAppearedInLocationWithHttpInfo
     *
     * Client appeared in location
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAppearedinlocationBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAppearedInLocationWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientAppearedInLocationRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAppearedInLocationAsync
     *
     * Client appeared in location
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAppearedinlocationBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAppearedInLocationAsync($api_version, $body = null)
    {
        return $this->clientAppearedInLocationAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAppearedInLocationAsyncWithHttpInfo
     *
     * Client appeared in location
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAppearedinlocationBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAppearedInLocationAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientAppearedInLocationRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAppearedInLocation'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAppearedinlocationBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAppearedInLocationRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientAppearedInLocation'
            );
        }

        $resourcePath = '/events/appeared-in-location';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientAssignedToCompany
     *
     * Client assigned to company
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAssignedtocompanyBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientAssignedToCompany($api_version, $body = null)
    {
        $this->clientAssignedToCompanyWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientAssignedToCompanyWithHttpInfo
     *
     * Client assigned to company
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAssignedtocompanyBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientAssignedToCompanyWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientAssignedToCompanyRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientAssignedToCompanyAsync
     *
     * Client assigned to company
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAssignedtocompanyBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAssignedToCompanyAsync($api_version, $body = null)
    {
        return $this->clientAssignedToCompanyAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientAssignedToCompanyAsyncWithHttpInfo
     *
     * Client assigned to company
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAssignedtocompanyBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientAssignedToCompanyAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientAssignedToCompanyRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientAssignedToCompany'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsAssignedtocompanyBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientAssignedToCompanyRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientAssignedToCompany'
            );
        }

        $resourcePath = '/events/assigned-to-company';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientCancelledPushNotifications
     *
     * Client cancelled push notifications
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\PushCancelledBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientCancelledPushNotifications($api_version, $body = null)
    {
        $this->clientCancelledPushNotificationsWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientCancelledPushNotificationsWithHttpInfo
     *
     * Client cancelled push notifications
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushCancelledBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientCancelledPushNotificationsWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientCancelledPushNotificationsRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientCancelledPushNotificationsAsync
     *
     * Client cancelled push notifications
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushCancelledBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientCancelledPushNotificationsAsync($api_version, $body = null)
    {
        return $this->clientCancelledPushNotificationsAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientCancelledPushNotificationsAsyncWithHttpInfo
     *
     * Client cancelled push notifications
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushCancelledBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientCancelledPushNotificationsAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientCancelledPushNotificationsRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientCancelledPushNotifications'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushCancelledBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientCancelledPushNotificationsRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientCancelledPushNotifications'
            );
        }

        $resourcePath = '/events/push/cancelled';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientCancelledTransaction
     *
     * Client cancelled transaction
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCancelledtransactionBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientCancelledTransaction($api_version, $body = null)
    {
        $this->clientCancelledTransactionWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientCancelledTransactionWithHttpInfo
     *
     * Client cancelled transaction
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCancelledtransactionBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientCancelledTransactionWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientCancelledTransactionRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientCancelledTransactionAsync
     *
     * Client cancelled transaction
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCancelledtransactionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientCancelledTransactionAsync($api_version, $body = null)
    {
        return $this->clientCancelledTransactionAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientCancelledTransactionAsyncWithHttpInfo
     *
     * Client cancelled transaction
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCancelledtransactionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientCancelledTransactionAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientCancelledTransactionRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientCancelledTransaction'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCancelledtransactionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientCancelledTransactionRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientCancelledTransaction'
            );
        }

        $resourcePath = '/events/cancelled-transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientClickedPushNotification
     *
     * Client clicked push notification
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\PushClickedBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientClickedPushNotification($api_version, $body = null)
    {
        $this->clientClickedPushNotificationWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientClickedPushNotificationWithHttpInfo
     *
     * Client clicked push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushClickedBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientClickedPushNotificationWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientClickedPushNotificationRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientClickedPushNotificationAsync
     *
     * Client clicked push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushClickedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientClickedPushNotificationAsync($api_version, $body = null)
    {
        return $this->clientClickedPushNotificationAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientClickedPushNotificationAsyncWithHttpInfo
     *
     * Client clicked push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushClickedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientClickedPushNotificationAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientClickedPushNotificationRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientClickedPushNotification'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushClickedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientClickedPushNotificationRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientClickedPushNotification'
            );
        }

        $resourcePath = '/events/push/clicked';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientCompletedTransaction
     *
     * Client completed transaction
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCompletedtransactionBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientCompletedTransaction($api_version, $body = null)
    {
        $this->clientCompletedTransactionWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientCompletedTransactionWithHttpInfo
     *
     * Client completed transaction
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCompletedtransactionBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientCompletedTransactionWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientCompletedTransactionRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientCompletedTransactionAsync
     *
     * Client completed transaction
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCompletedtransactionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientCompletedTransactionAsync($api_version, $body = null)
    {
        return $this->clientCompletedTransactionAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientCompletedTransactionAsyncWithHttpInfo
     *
     * Client completed transaction
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCompletedtransactionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientCompletedTransactionAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientCompletedTransactionRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientCompletedTransaction'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCompletedtransactionBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientCompletedTransactionRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientCompletedTransaction'
            );
        }

        $resourcePath = '/events/completed-transaction';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientHitTimer
     *
     * Client hit timer
     *
     * @param  \Synerise\DataManagement\Model\EventsHittimerBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientHitTimer($body, $api_version)
    {
        $this->clientHitTimerWithHttpInfo($body, $api_version);
    }

    /**
     * Operation clientHitTimerWithHttpInfo
     *
     * Client hit timer
     *
     * @param  \Synerise\DataManagement\Model\EventsHittimerBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientHitTimerWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientHitTimerRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientHitTimerAsync
     *
     * Client hit timer
     *
     * @param  \Synerise\DataManagement\Model\EventsHittimerBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientHitTimerAsync($body, $api_version)
    {
        return $this->clientHitTimerAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientHitTimerAsyncWithHttpInfo
     *
     * Client hit timer
     *
     * @param  \Synerise\DataManagement\Model\EventsHittimerBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientHitTimerAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientHitTimerRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientHitTimer'
     *
     * @param  \Synerise\DataManagement\Model\EventsHittimerBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientHitTimerRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clientHitTimer'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientHitTimer'
            );
        }

        $resourcePath = '/events/hit-timer';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientLoggedIn
     *
     * Client logged in
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedinBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientLoggedIn($api_version, $body = null)
    {
        $this->clientLoggedInWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientLoggedInWithHttpInfo
     *
     * Client logged in
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedinBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientLoggedInWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientLoggedInRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientLoggedInAsync
     *
     * Client logged in
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedinBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientLoggedInAsync($api_version, $body = null)
    {
        return $this->clientLoggedInAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientLoggedInAsyncWithHttpInfo
     *
     * Client logged in
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedinBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientLoggedInAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientLoggedInRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientLoggedIn'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedinBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientLoggedInRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientLoggedIn'
            );
        }

        $resourcePath = '/events/logged-in';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientLoggedOut
     *
     * Client logged out
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedoutBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientLoggedOut($api_version, $body = null)
    {
        $this->clientLoggedOutWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientLoggedOutWithHttpInfo
     *
     * Client logged out
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedoutBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientLoggedOutWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientLoggedOutRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientLoggedOutAsync
     *
     * Client logged out
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedoutBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientLoggedOutAsync($api_version, $body = null)
    {
        return $this->clientLoggedOutAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientLoggedOutAsyncWithHttpInfo
     *
     * Client logged out
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedoutBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientLoggedOutAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientLoggedOutRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientLoggedOut'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsLoggedoutBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientLoggedOutRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientLoggedOut'
            );
        }

        $resourcePath = '/events/logged-out';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientReceivedPushNotification
     *
     * Client received push notification
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\PushReceivedBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientReceivedPushNotification($api_version, $body = null)
    {
        $this->clientReceivedPushNotificationWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientReceivedPushNotificationWithHttpInfo
     *
     * Client received push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushReceivedBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientReceivedPushNotificationWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientReceivedPushNotificationRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientReceivedPushNotificationAsync
     *
     * Client received push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushReceivedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientReceivedPushNotificationAsync($api_version, $body = null)
    {
        return $this->clientReceivedPushNotificationAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientReceivedPushNotificationAsyncWithHttpInfo
     *
     * Client received push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushReceivedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientReceivedPushNotificationAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientReceivedPushNotificationRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientReceivedPushNotification'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushReceivedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientReceivedPushNotificationRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientReceivedPushNotification'
            );
        }

        $resourcePath = '/events/push/received';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientRegistered
     *
     * Client registered
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsRegisteredBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientRegistered($api_version, $body = null)
    {
        $this->clientRegisteredWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientRegisteredWithHttpInfo
     *
     * Client registered
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsRegisteredBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientRegisteredWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientRegisteredRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientRegisteredAsync
     *
     * Client registered
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsRegisteredBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientRegisteredAsync($api_version, $body = null)
    {
        return $this->clientRegisteredAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientRegisteredAsyncWithHttpInfo
     *
     * Client registered
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsRegisteredBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientRegisteredAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientRegisteredRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientRegistered'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsRegisteredBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientRegisteredRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientRegistered'
            );
        }

        $resourcePath = '/events/registered';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientRemovedProductFromCart
     *
     * Client removed product from cart
     *
     * @param  \Synerise\DataManagement\Model\EventsRemovedfromcartBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientRemovedProductFromCart($body, $api_version)
    {
        $this->clientRemovedProductFromCartWithHttpInfo($body, $api_version);
    }

    /**
     * Operation clientRemovedProductFromCartWithHttpInfo
     *
     * Client removed product from cart
     *
     * @param  \Synerise\DataManagement\Model\EventsRemovedfromcartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientRemovedProductFromCartWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientRemovedProductFromCartRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientRemovedProductFromCartAsync
     *
     * Client removed product from cart
     *
     * @param  \Synerise\DataManagement\Model\EventsRemovedfromcartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientRemovedProductFromCartAsync($body, $api_version)
    {
        return $this->clientRemovedProductFromCartAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientRemovedProductFromCartAsyncWithHttpInfo
     *
     * Client removed product from cart
     *
     * @param  \Synerise\DataManagement\Model\EventsRemovedfromcartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientRemovedProductFromCartAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientRemovedProductFromCartRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientRemovedProductFromCart'
     *
     * @param  \Synerise\DataManagement\Model\EventsRemovedfromcartBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientRemovedProductFromCartRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clientRemovedProductFromCart'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientRemovedProductFromCart'
            );
        }

        $resourcePath = '/events/removed-from-cart';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientSearched
     *
     * Client searched
     *
     * @param  \Synerise\DataManagement\Model\EventsSearchedBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientSearched($body, $api_version)
    {
        $this->clientSearchedWithHttpInfo($body, $api_version);
    }

    /**
     * Operation clientSearchedWithHttpInfo
     *
     * Client searched
     *
     * @param  \Synerise\DataManagement\Model\EventsSearchedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientSearchedWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientSearchedRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientSearchedAsync
     *
     * Client searched
     *
     * @param  \Synerise\DataManagement\Model\EventsSearchedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientSearchedAsync($body, $api_version)
    {
        return $this->clientSearchedAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientSearchedAsyncWithHttpInfo
     *
     * Client searched
     *
     * @param  \Synerise\DataManagement\Model\EventsSearchedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientSearchedAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientSearchedRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientSearched'
     *
     * @param  \Synerise\DataManagement\Model\EventsSearchedBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientSearchedRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clientSearched'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientSearched'
            );
        }

        $resourcePath = '/events/searched';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientShared
     *
     * Client shared
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsSharedBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientShared($api_version, $body = null)
    {
        $this->clientSharedWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientSharedWithHttpInfo
     *
     * Client shared
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsSharedBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientSharedWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientSharedRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientSharedAsync
     *
     * Client shared
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsSharedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientSharedAsync($api_version, $body = null)
    {
        return $this->clientSharedAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientSharedAsyncWithHttpInfo
     *
     * Client shared
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsSharedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientSharedAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientSharedRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientShared'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsSharedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientSharedRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientShared'
            );
        }

        $resourcePath = '/events/shared';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientViewedProduct
     *
     * Client viewed product
     *
     * @param  \Synerise\DataManagement\Model\EventsProductviewBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientViewedProduct($body, $api_version)
    {
        $this->clientViewedProductWithHttpInfo($body, $api_version);
    }

    /**
     * Operation clientViewedProductWithHttpInfo
     *
     * Client viewed product
     *
     * @param  \Synerise\DataManagement\Model\EventsProductviewBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientViewedProductWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientViewedProductRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientViewedProductAsync
     *
     * Client viewed product
     *
     * @param  \Synerise\DataManagement\Model\EventsProductviewBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientViewedProductAsync($body, $api_version)
    {
        return $this->clientViewedProductAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientViewedProductAsyncWithHttpInfo
     *
     * Client viewed product
     *
     * @param  \Synerise\DataManagement\Model\EventsProductviewBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientViewedProductAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->clientViewedProductRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientViewedProduct'
     *
     * @param  \Synerise\DataManagement\Model\EventsProductviewBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientViewedProductRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling clientViewedProduct'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientViewedProduct'
            );
        }

        $resourcePath = '/events/product-view';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientViewedPushNotification
     *
     * Client viewed push notification
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\PushViewedBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientViewedPushNotification($api_version, $body = null)
    {
        $this->clientViewedPushNotificationWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientViewedPushNotificationWithHttpInfo
     *
     * Client viewed push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushViewedBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientViewedPushNotificationWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientViewedPushNotificationRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientViewedPushNotificationAsync
     *
     * Client viewed push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushViewedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientViewedPushNotificationAsync($api_version, $body = null)
    {
        return $this->clientViewedPushNotificationAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientViewedPushNotificationAsyncWithHttpInfo
     *
     * Client viewed push notification
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushViewedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientViewedPushNotificationAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientViewedPushNotificationRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientViewedPushNotification'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\PushViewedBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientViewedPushNotificationRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientViewedPushNotification'
            );
        }

        $resourcePath = '/events/push/viewed';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation clientVisitedScreen
     *
     * Client visited screen
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsVisitedscreenBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function clientVisitedScreen($api_version, $body = null)
    {
        $this->clientVisitedScreenWithHttpInfo($api_version, $body);
    }

    /**
     * Operation clientVisitedScreenWithHttpInfo
     *
     * Client visited screen
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsVisitedscreenBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function clientVisitedScreenWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientVisitedScreenRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation clientVisitedScreenAsync
     *
     * Client visited screen
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsVisitedscreenBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientVisitedScreenAsync($api_version, $body = null)
    {
        return $this->clientVisitedScreenAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation clientVisitedScreenAsyncWithHttpInfo
     *
     * Client visited screen
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsVisitedscreenBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function clientVisitedScreenAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->clientVisitedScreenRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'clientVisitedScreen'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsVisitedscreenBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function clientVisitedScreenRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling clientVisitedScreen'
            );
        }

        $resourcePath = '/events/visited-screen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createATransaction
     *
     * Create a transaction
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createATransaction($body, $api_version)
    {
        $this->createATransactionWithHttpInfo($body, $api_version);
    }

    /**
     * Operation createATransactionWithHttpInfo
     *
     * Create a transaction
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createATransactionWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->createATransactionRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createATransactionAsync
     *
     * Create a transaction
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createATransactionAsync($body, $api_version)
    {
        return $this->createATransactionAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createATransactionAsyncWithHttpInfo
     *
     * Create a transaction
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createATransactionAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->createATransactionRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createATransaction'
     *
     * @param  \Synerise\DataManagement\Model\TransactionsBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createATransactionRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createATransaction'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling createATransaction'
            );
        }

        $resourcePath = '/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation customEvent
     *
     * Custom event
     *
     * @param  string $api_version api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCustomBody $body body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function customEvent($api_version, $body = null)
    {
        $this->customEventWithHttpInfo($api_version, $body);
    }

    /**
     * Operation customEventWithHttpInfo
     *
     * Custom event
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCustomBody $body (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function customEventWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->customEventRequest($api_version, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation customEventAsync
     *
     * Custom event
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCustomBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customEventAsync($api_version, $body = null)
    {
        return $this->customEventAsyncWithHttpInfo($api_version, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation customEventAsyncWithHttpInfo
     *
     * Custom event
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCustomBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function customEventAsyncWithHttpInfo($api_version, $body = null)
    {
        $returnType = '';
        $request = $this->customEventRequest($api_version, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'customEvent'
     *
     * @param  string $api_version (required)
     * @param  \Synerise\DataManagement\Model\EventsCustomBody $body (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function customEventRequest($api_version, $body = null)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling customEvent'
            );
        }

        $resourcePath = '/events/custom';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClientEvents
     *
     * Get Client events as Business Profile
     *
     * @param  int $client_id The ID of the Client profile (required)
     * @param  string $content_type content_type (required)
     * @param  string $api_version api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\DataManagement\Model\InlineResponse2004[]
     */
    public function getClientEvents($client_id, $content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        list($response) = $this->getClientEventsWithHttpInfo($client_id, $content_type, $api_version, $time_from, $time_to, $action, $limit);
        return $response;
    }

    /**
     * Operation getClientEventsWithHttpInfo
     *
     * Get Client events as Business Profile
     *
     * @param  int $client_id The ID of the Client profile (required)
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\DataManagement\Model\InlineResponse2004[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getClientEventsWithHttpInfo($client_id, $content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        $returnType = '\Synerise\DataManagement\Model\InlineResponse2004[]';
        $request = $this->getClientEventsRequest($client_id, $content_type, $api_version, $time_from, $time_to, $action, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse2004[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClientEventsAsync
     *
     * Get Client events as Business Profile
     *
     * @param  int $client_id The ID of the Client profile (required)
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientEventsAsync($client_id, $content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        return $this->getClientEventsAsyncWithHttpInfo($client_id, $content_type, $api_version, $time_from, $time_to, $action, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClientEventsAsyncWithHttpInfo
     *
     * Get Client events as Business Profile
     *
     * @param  int $client_id The ID of the Client profile (required)
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientEventsAsyncWithHttpInfo($client_id, $content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        $returnType = '\Synerise\DataManagement\Model\InlineResponse2004[]';
        $request = $this->getClientEventsRequest($client_id, $content_type, $api_version, $time_from, $time_to, $action, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClientEvents'
     *
     * @param  int $client_id The ID of the Client profile (required)
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClientEventsRequest($client_id, $content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getClientEvents'
            );
        }
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling getClientEvents'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling getClientEvents'
            );
        }

        $resourcePath = '/events/by-client/{clientID}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($time_from !== null) {
            $queryParams['time[from]'] = ObjectSerializer::toQueryValue($time_from, 'date-time');
        }
        // query params
        if ($time_to !== null) {
            $queryParams['time[to]'] = ObjectSerializer::toQueryValue($time_to, 'date-time');
        }
        // query params
        if ($action !== null) {
            $queryParams['action'] = ObjectSerializer::toQueryValue($action, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }

        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientID' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getClientOwnEvents
     *
     * Get Client's events as Client
     *
     * @param  string $content_type content_type (required)
     * @param  string $api_version api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\DataManagement\Model\InlineResponse2004[]
     */
    public function getClientOwnEvents($content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        list($response) = $this->getClientOwnEventsWithHttpInfo($content_type, $api_version, $time_from, $time_to, $action, $limit);
        return $response;
    }

    /**
     * Operation getClientOwnEventsWithHttpInfo
     *
     * Get Client's events as Client
     *
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\DataManagement\Model\InlineResponse2004[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getClientOwnEventsWithHttpInfo($content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        $returnType = '\Synerise\DataManagement\Model\InlineResponse2004[]';
        $request = $this->getClientOwnEventsRequest($content_type, $api_version, $time_from, $time_to, $action, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse2004[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getClientOwnEventsAsync
     *
     * Get Client's events as Client
     *
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientOwnEventsAsync($content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        return $this->getClientOwnEventsAsyncWithHttpInfo($content_type, $api_version, $time_from, $time_to, $action, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getClientOwnEventsAsyncWithHttpInfo
     *
     * Get Client's events as Client
     *
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getClientOwnEventsAsyncWithHttpInfo($content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        $returnType = '\Synerise\DataManagement\Model\InlineResponse2004[]';
        $request = $this->getClientOwnEventsRequest($content_type, $api_version, $time_from, $time_to, $action, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getClientOwnEvents'
     *
     * @param  string $content_type (required)
     * @param  string $api_version (required)
     * @param  \DateTime $time_from Start of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the results are returned starting with the oldest entry in the database. (optional)
     * @param  \DateTime $time_to End of the time range to query. UTC time in ISO 8601 (for example, &#x60;2020-10-19T13:47:53Z&#x60;). If no value is provided, the current time applies. (optional)
     * @param  string $action Filter events by action type. For example, to retrieve completed transactions, enter &#x60;transaction.charge&#x60; (optional)
     * @param  int $limit The number of events to retrieve (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getClientOwnEventsRequest($content_type, $api_version, $time_from = null, $time_to = null, $action = null, $limit = null)
    {
        // verify the required parameter 'content_type' is set
        if ($content_type === null || (is_array($content_type) && count($content_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $content_type when calling getClientOwnEvents'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling getClientOwnEvents'
            );
        }

        $resourcePath = '/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($time_from !== null) {
            $queryParams['time[from]'] = ObjectSerializer::toQueryValue($time_from, 'date-time');
        }
        // query params
        if ($time_to !== null) {
            $queryParams['time[to]'] = ObjectSerializer::toQueryValue($time_to, 'date-time');
        }
        // query params
        if ($action !== null) {
            $queryParams['action'] = ObjectSerializer::toQueryValue($action, null);
        }
        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit, null);
        }
        // header params
        if ($content_type !== null) {
            $headerParams['Content-Type'] = ObjectSerializer::toHeaderValue($content_type);
        }
        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getServerTime
     *
     * Get server time
     *
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Synerise\DataManagement\Model\InlineResponse2005
     */
    public function getServerTime($api_version)
    {
        list($response) = $this->getServerTimeWithHttpInfo($api_version);
        return $response;
    }

    /**
     * Operation getServerTimeWithHttpInfo
     *
     * Get server time
     *
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Synerise\DataManagement\Model\InlineResponse2005, HTTP status code, HTTP response headers (array of strings)
     */
    public function getServerTimeWithHttpInfo($api_version)
    {
        $returnType = '\Synerise\DataManagement\Model\InlineResponse2005';
        $request = $this->getServerTimeRequest($api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse2005',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getServerTimeAsync
     *
     * Get server time
     *
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getServerTimeAsync($api_version)
    {
        return $this->getServerTimeAsyncWithHttpInfo($api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getServerTimeAsyncWithHttpInfo
     *
     * Get server time
     *
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getServerTimeAsyncWithHttpInfo($api_version)
    {
        $returnType = '\Synerise\DataManagement\Model\InlineResponse2005';
        $request = $this->getServerTimeRequest($api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getServerTime'
     *
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getServerTimeRequest($api_version)
    {
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling getServerTime'
            );
        }

        $resourcePath = '/server/time';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recommendationClicked
     *
     * Client clicked recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationclickBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function recommendationClicked($body, $api_version)
    {
        $this->recommendationClickedWithHttpInfo($body, $api_version);
    }

    /**
     * Operation recommendationClickedWithHttpInfo
     *
     * Client clicked recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationclickBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function recommendationClickedWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->recommendationClickedRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recommendationClickedAsync
     *
     * Client clicked recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationclickBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationClickedAsync($body, $api_version)
    {
        return $this->recommendationClickedAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recommendationClickedAsyncWithHttpInfo
     *
     * Client clicked recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationclickBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationClickedAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->recommendationClickedRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recommendationClicked'
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationclickBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function recommendationClickedRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling recommendationClicked'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling recommendationClicked'
            );
        }

        $resourcePath = '/events/recommendation-click';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation recommendationSeen
     *
     * Client viewed recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationseenBody $body body (required)
     * @param  string $api_version api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function recommendationSeen($body, $api_version)
    {
        $this->recommendationSeenWithHttpInfo($body, $api_version);
    }

    /**
     * Operation recommendationSeenWithHttpInfo
     *
     * Client viewed recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationseenBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \Synerise\DataManagement\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function recommendationSeenWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->recommendationSeenRequest($body, $api_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 415:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Synerise\DataManagement\Model\InlineResponse4001',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation recommendationSeenAsync
     *
     * Client viewed recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationseenBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationSeenAsync($body, $api_version)
    {
        return $this->recommendationSeenAsyncWithHttpInfo($body, $api_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation recommendationSeenAsyncWithHttpInfo
     *
     * Client viewed recommendation
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationseenBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function recommendationSeenAsyncWithHttpInfo($body, $api_version)
    {
        $returnType = '';
        $request = $this->recommendationSeenRequest($body, $api_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'recommendationSeen'
     *
     * @param  \Synerise\DataManagement\Model\EventsRecommendationseenBody $body (required)
     * @param  string $api_version (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function recommendationSeenRequest($body, $api_version)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling recommendationSeen'
            );
        }
        // verify the required parameter 'api_version' is set
        if ($api_version === null || (is_array($api_version) && count($api_version) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $api_version when calling recommendationSeen'
            );
        }

        $resourcePath = '/events/recommendation-seen';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($api_version !== null) {
            $headerParams['Api-Version'] = ObjectSerializer::toHeaderValue($api_version);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

            // // this endpoint requires Bearer token
            if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
            }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
